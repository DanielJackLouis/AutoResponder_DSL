/*
 * generated by Xtext 2.26.0
 */
package uk.ac.kcl.inf.languages.autoresponder.validation

import org.eclipse.xtext.validation.Check
import uk.ac.kcl.inf.languages.autoresponder.autoResponder.ActivityStatement
import uk.ac.kcl.inf.languages.autoresponder.autoResponder.AutoResponderPackage
import uk.ac.kcl.inf.languages.autoresponder.autoResponder.Statement
import java.util.List
//import uk.ac.kcl.inf.languages.autoresponder.autoResponder.TerminationStatement
//import uk.ac.kcl.inf.languages.autoresponder.autoResponder.ActivityState
import uk.ac.kcl.inf.languages.autoresponder.autoResponder.ContactStatement
import uk.ac.kcl.inf.languages.autoresponder.autoResponder.StringExpression
import uk.ac.kcl.inf.languages.autoresponder.autoResponder.StringLiteral
import uk.ac.kcl.inf.languages.autoresponder.autoResponder.StringVarExpression
import uk.ac.kcl.inf.languages.autoresponder.autoResponder.AutoResponderProgram
import uk.ac.kcl.inf.languages.autoresponder.autoResponder.HearStatement
import uk.ac.kcl.inf.languages.autoresponder.autoResponder.InstructStatement
import uk.ac.kcl.inf.languages.autoresponder.autoResponder.TriggerStatement

/** 
 * This class contains custom validation rules. 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AutoResponderValidator extends AbstractAutoResponderValidator {
	
	public static val INVALID_ACTIVITY_NAME = 'uk.ac.kcl.inf.languages.autoresponder.INVALID_ACTIVITY_NAME';
	public static val ACTIVITY_NOT_HAVE_INPUT = 'uk.ac.kcl.inf.languages.autoresponder.ACTIVITY_NOT_HAVE_INPUT';
	public static val ACTIVITY_MORE_HAVE_INPUT = 'uk.ac.kcl.inf.languages.autoresponder.ACTIVITY_MORE_HAVE_INPUT'
	public static val NO_WAIT_FOR_INPUT = 'uk.ac.kcl.inf.languages.autoresponder.NO_WAIT_FOR_INPUT'
	public static val MORE_WAIT_FOR_INPUT = 'uk.ac.kcl.inf.languages.autoresponder.MORE_WAIT_FOR_INPUT'
	public static val WAIT_FOR_INPUT_IDX_NOT_CORRECT = 'uk.ac.kcl.inf.languages.autoresponder.WAIT_FOR_INPUT_IDX_NOT_CORRECT'
	public static val ORDER_NOT_CORRECT = 'uk.ac.kcl.inf.languages.autoresponder.ORDER_NOT_CORRECT'
	public static val ORDER_NOT_CORRECT_IN_ACTIVITY = 'uk.ac.kcl.inf.languages.autoresponder.ORDER_NOT_CORRECT_IN_ACTIVITY'
	public static val OPTION_IN_ACTIVITY_IS_NOT_CORRECT = 'uk.ac.kcl.inf.languages.autoresponder.OPTION_IN_ACTIVITY_IS_NOT_CORRECT'
	public static val PHONE_NUMBER_WITHOUT_COUNTRYNUM = 'uk.ac.kcl.inf.languages.autoresponder.PHONE_NUMBER_WITHOUT_COUNTRYNUM'
	public static val PHONE_NUMBER_UNCORRECT = 'uk.ac.kcl.inf.languages.autoresponder.PHONE_NUMBER_UNCORRECT'
	
	@Check 
	def checkActivityNamesStartWithUppercaseCharacter(ActivityStatement stmt) {
		if (Character.isLowerCase(stmt.name.charAt(0))) {
			warning('Activity name should start with a upper-case character', stmt, 
				AutoResponderPackage.Literals.ACTIVITY_STATEMENT__NAME,
				INVALID_ACTIVITY_NAME
			)
		}
	}
	
	@Check(NORMAL)
	def checkAlwaysHaveInputInActivity(ActivityStatement stmt) {
		if (!stmt.statements.checkAlwaysHaveInputCommand(false)) {
			warning('Activity does not have WaitForInput', stmt, 
				AutoResponderPackage.Literals.ACTIVITY_STATEMENT__NAME, 
				ACTIVITY_NOT_HAVE_INPUT
			)
		}
	}
	
	@Check(NORMAL)
	def checkAlwaysHaveOneInputInActivity(ActivityStatement stmt) {
		if ( stmt.statements.countInputCommand > 1) {
			warning('Activity have more than one WaitForInput', stmt, 
				AutoResponderPackage.Literals.ACTIVITY_STATEMENT__NAME, 
				ACTIVITY_MORE_HAVE_INPUT
			)
		}
	}
	
//	private def checkAlwaysHaveTerminationAtEnd(List<Statement> statements, boolean initialState) {
//		statements.fold(true)[previousState, stmt |
//			stmt.predictActivityOutcome(previousState)
//		]
//	}
	
//	private dispatch def boolean predictActivityOutcome(Statement stmt, boolean previousState) { previousState }
//	private dispatch def boolean predictActivityOutcome(TerminationStatement stmt, boolean previousState) { stmt.state === ActivityState.BACK }
//	private dispatch def boolean predictActivityOutcome(ActivityStatement stmt, boolean previousState) {
//		stmt.statements.checkAlwaysHaveTerminationAtEnd(previousState)
//	}
	
	// In the program, there must be one hearer
	@Check(NORMAL)
	def checkAlwaysHaveRightStructure(AutoResponderProgram program) {
		if ( !program.statements.checkAlwaysHaveInputCommand(false) ) {	
			warning('WaitForInput is missing', program, 
				AutoResponderPackage.Literals.AUTO_RESPONDER_PROGRAM__STATEMENTS, 
				NO_WAIT_FOR_INPUT
			)
		}					
	}
	
	@Check(NORMAL)
	def checkOnlyHaveOneInput(AutoResponderProgram program) {
		if ( program.statements.countInputCommand > 1 ) {
			warning('More than one WaitForInput', program, 
				AutoResponderPackage.Literals.AUTO_RESPONDER_PROGRAM__STATEMENTS, 
				MORE_WAIT_FOR_INPUT
			)
		}		
	}
	
	def checkAlwaysHaveInputCommand(List<Statement> statements, boolean initialState) {
		if (statements.countInputCommand === 1) {
			return !initialState
		}
		initialState
	}
	
	def countInputCommand(List<Statement> statements) {
		var count = 0
		for (Statement stmt: statements) {
			if (stmt instanceof HearStatement) {
				count++
			} 
		}
		count
	}
	
	// Wihtih the activity, waitforinput must be place before next Activity, behind the instruct	
	@Check(NORMAL)
	def checkInstructWillShow(AutoResponderProgram program) {
		var int InstruIdx = 0;
		var int HearIdx = 0;
		var int TriIdx = 9999; 
		
		for (var i = 0; i < program.statements.size; i++ ) {
			if (program.statements.get(i) instanceof InstructStatement) {
				if( InstruIdx < i ) {
					InstruIdx = i
					}
			}
			if (program.statements.get(i) instanceof HearStatement) {
				if( HearIdx < i ) {
					HearIdx = i
				} 
			}
			if (program.statements.get(i) instanceof TriggerStatement) {
				if( i !==0 && TriIdx > i ) {
					TriIdx = i
				} 
			}	
		}

		if ( !((InstruIdx < HearIdx) && (HearIdx < TriIdx)) ) {
			warning('The statement order should be Instruct, WaitForInput, Input', program, 
				AutoResponderPackage.Literals.AUTO_RESPONDER_PROGRAM__STATEMENTS, 
				ORDER_NOT_CORRECT
			)
			// System.out.println(InstruIdx +" "+ HearIdx + " " + TriIdx)
		}	
	}
	
	@Check(NORMAL)
	def checkInstructWillShow(ActivityStatement stmt) {
		var int InstruIdx = 0;
		var int HearIdx = 0;
		var int TriIdx = 9999; 
		
		for (var i = 0; i < stmt.statements.size; i++ ) {
			if (stmt.statements.get(i) instanceof InstructStatement) {
				if( InstruIdx < i ) {
					InstruIdx = i
					}
			}
			if (stmt.statements.get(i) instanceof HearStatement) {
				if( HearIdx < i ) {
					HearIdx = i
				} 
			}
			if (stmt.statements.get(i) instanceof TriggerStatement) {
				if( i !==0 && TriIdx > i ) {
					TriIdx = i
				} 
			}	
		}

		if ( !((InstruIdx < HearIdx) && (HearIdx < TriIdx)) ) {
			warning('The statement order should be Instruct, WaitForInput, Input', stmt, 
				AutoResponderPackage.Literals.ACTIVITY_STATEMENT__NAME, 
				ORDER_NOT_CORRECT_IN_ACTIVITY
			)
			// System.out.println(InstruIdx +" "+ HearIdx + " " + TriIdx)
		}	
	}
	
	@Check(NORMAL)
	def checkInputHasRightIdx(HearStatement stmt) {
		if (stmt.predictInputIdx !== stmt.value) {
			warning('The index of WaitForInput is wrong', stmt, 
				AutoResponderPackage.Literals.HEAR_STATEMENT__VALUE, 
				WAIT_FOR_INPUT_IDX_NOT_CORRECT
			)
		}
	}
	
	def predictInputIdx(HearStatement stmt) {
		var int idx = 0
		var container = stmt.eContainer
		while (!(container instanceof AutoResponderProgram)) {
			container = container.eContainer
			idx++
		}
		idx/2 
		// Because of the triggerStatement and activityStatement, the gap is 2 
		// Divided by 2 at last
	}
	
	@Check(NORMAL)
	def checkTriggerOptionInActivityIsCorrect(ActivityStatement stmt) {
		var statement = stmt.eContainer as TriggerStatement
		if ( !statement.name.equals(stmt.last_input.generateJavaStringExpression) ) {
			warning('Trigger option in Activity is not Correct', stmt, 
				AutoResponderPackage.Literals.ACTIVITY_STATEMENT__LAST_INPUT, 
				OPTION_IN_ACTIVITY_IS_NOT_CORRECT
			)
		}
	}
	
	
	
	
	// Checking phone number
	@Check
	def checkPhoneNumberCorrect(ContactStatement stmt) {
		if ( !(stmt.phoneNumber.generateJavaStringExpression.substring(0, 3).equals("+44")) ){
			warning('Phone Number is not a UK number', stmt, 
				AutoResponderPackage.Literals.CONTACT_STATEMENT__PHONE_NUMBER,
				PHONE_NUMBER_WITHOUT_COUNTRYNUM
			)
		} else if (stmt.phoneNumber.generateJavaStringExpression.substring(0, 3).equals("+44") && 
			stmt.phoneNumber.generateJavaStringExpression.length !== 13) {
				warning('Phone number is not correct', stmt, 
				AutoResponderPackage.Literals.CONTACT_STATEMENT__PHONE_NUMBER,
				PHONE_NUMBER_UNCORRECT
			)
			
		}
	}
	
	dispatch def String generateJavaStringExpression(StringExpression exp) {}
	dispatch def String generateJavaStringExpression(StringLiteral exp) { exp.^val }
	dispatch def String generateJavaStringExpression(StringVarExpression exp) { exp.^var.string }
}
